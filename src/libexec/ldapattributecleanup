#!/usr/bin/perl
#
# SPDX-FileCopyrightText: 2023 Zextras <https://www.zextras.com>
#
# SPDX-License-Identifier: GPL-2.0-only
#

=begin
About this script:
    → start LDAP
    → bind ldap
    → get the value of zimbraLDAPSchemaVersion from LDAP
    → iterate through what we call ldap_attribute_cleanup_dir containing cleanup JSON files
    → sort cleanup files in ascending order
    → compare timestamp from cleanup filename with zimbraLDAPSchemaVersion. if it’s greater, that
    means we need to apply cleanups from this update file
    → remove attributes declared in cleanup by searching all entries containing said attribute 
    → unbind ldap
    → exit
=cut

use strict;
use lib "/opt/zextras/common/lib/perl5";
use Zimbra::Util::Common;
use File::Path;
use Net::LDAP;
use Net::LDAP::LDIF;
use Net::LDAP::Entry;
use JSON::PP;
use File::Basename;
use experimental 'smartmatch';

&print_separater("-", "80");
print "Starting LDAP cleanup...\n";

my $source_config_dir = "/opt/zextras/common/etc/openldap";
my $ldap_attribute_cleanup_dir = "$source_config_dir/zimbra/cleanup/attrs";
my $ldap_root_password = getLocalConfig("ldap_root_password");
my $ldap_master_url = getLocalConfig("ldap_master_url");
my $ldap_is_master = getLocalConfig("ldap_is_master");
my $ldap_starttls_supported = getLocalConfig("ldap_starttls_supported");
my $zimbra_tmp_directory = getLocalConfig("zimbra_tmp_directory");

if (lc($ldap_is_master) ne "true") {
    print STDERR "Must run on master ldap.\n";
    exit(1);
}

if (!-d $zimbra_tmp_directory) {
    File::Path::mkpath("$zimbra_tmp_directory");
}

my $rc = qx(/opt/zextras/bin/ldap start);

my @masters = split(/ /, $ldap_master_url);
my $master_ref = \@masters;
my $ldap = Net::LDAP->new($master_ref) or die "$@";

# startTLS Operation if available
my $mesg;
if ($ldap_master_url !~ /^ldaps/i) {
    if ($ldap_starttls_supported) {
        $mesg = $ldap->start_tls(
            verify => 'none',
            capath => "/opt/zextras/conf/ca",
        ) or die "start_tls: $@";
        $mesg->code && die "TLS: " . $mesg->error . "\n";
    }
}

# bind ldap or exit with error on failure
$mesg = $ldap->bind("cn=config", password => "$ldap_root_password");
if ($mesg->code()) {
    print STDERR "Unable to bind: $!";
    exit(1);
}

# get zimbraLDAPSchemaVersion from LDAP server
my $zimbra_ldap_schema_version;
my $last_applied_update_version;
my $result = $ldap->search(base => 'cn=zimbra', filter => '(zimbraLDAPSchemaVersion=*)', attrs => [ 'zimbraLDAPSchemaVersion' ]);
if ( $result->count > 0 ) {
    my $entry = $result->entry(0);
    $zimbra_ldap_schema_version = $entry->get_value('zimbraLDAPSchemaVersion');
    $last_applied_update_version = $zimbra_ldap_schema_version;
    &print_separater("-", "40");
    print STDOUT "Current installed LDAP Schema Version: $zimbra_ldap_schema_version \n";
}
else {
    print STDERR "Unable to get zimbraLDAPSchemaVersion from LDAP.\n";
    $ldap->unbind;
    exit(1);
}

# read updates folder and prepare each file for update;
if (-d "$ldap_attribute_cleanup_dir") {
    my $failed = 0;
    opendir(DIR, "$ldap_attribute_cleanup_dir") or die "Cannot opendir $ldap_attribute_cleanup_dir: $!\n";
    my @cleanup_files =  sort { $a <=> $b } readdir(DIR);
    while ( my $file = shift @cleanup_files ) {
        next unless (-f "$ldap_attribute_cleanup_dir/$file");
        next unless ($file =~ m/json/);
        my $infile = "$ldap_attribute_cleanup_dir/$file";
        $failed = &prepare_cleanup_file($infile);
        if ($failed) {
            print STDERR "Cleanup ", $file, "failed.\n";
            # exit while loop
            last;
        }
    }
    closedir DIR;
    &print_separater("-", "80");
    $ldap->unbind;
    if ($failed) {
        print STDERR "Cleanup failed.\n";
        &print_separater("-", "80");
        exit(1);
    }
    print STDOUT "Cleanup completed.\n";
    &print_separater("-", "80");
    exit(0);
}
else {
    print STDERR "LDAP cleanup directory($ldap_attribute_cleanup_dir) not found.\nUnable to process LDAP cleanup.\n";
    $ldap->unbind;
    exit(1);
}

=begin print_separater
    print_separater($char<string>, $length<int>);
Prints $char $length times prepended by a new line;
=cut
sub print_separater(){
    my ($char, $length) = @_;
    print $char x $length;
    print "\n";
}

=begin getLocalConfig
    getLocalConfig($key<string>);
Returns value of key from localconfig, using zmlocalconfig util.
=cut
sub getLocalConfig {
    my $key = shift;

    return $main::loaded{lc}{$key}
        if (exists $main::loaded{lc}{$key});

    my $val = qx(/opt/zextras/bin/zmlocalconfig -x -s -m nokey ${key} 2> /dev/null);
    chomp $val;
    $main::loaded{lc}{$key} = $val;
    return $val;
}

=begin update_zimbra_ldap_schema_version
    update_zimbra_ldap_schema_version($last_applied_update_version<string>);
update the value of zimbraLDAPSchemaVersion in LDAP.
return failed status (true/false).
=cut
sub update_zimbra_ldap_schema_version(){
    my ($new_timestamp) = @_;
    if( $zimbra_ldap_schema_version ne $new_timestamp ) {
        my $result = $ldap->search(base => 'cn=zimbra', filter => '(zimbraLDAPSchemaVersion=*)', attrs => [ 'zimbraLDAPSchemaVersion' ]);
        if ( $result->count > 0 ) {
            my $entry = $result->entry(0);
            if( $entry ){
                $entry->replace( zimbraLDAPSchemaVersion => $new_timestamp );
            }
            my $msg = $entry->update( $ldap );
            if ( $msg->code() ) {
                print STDERR "Error msg: ", $entry->dn(), " ", $msg->error(), "\n";
                return 1;
            }
        }
        print STDOUT "LDAP schema upgraded to version $new_timestamp \n";
        return 0;
    }
}

=begin prepare_cleanup_file
    prepare_cleanup_file($filename<string>);
Checks cleanup file timestamp again schema version and applies it if eligible.
returns failed status (true/false)
=cut
sub prepare_cleanup_file(){
    my ($infile) = @_;
    my $failed = 0;
    my $infile_base_name = basename($infile);
    (my $timestamp_from_file = $infile_base_name) =~ s/\.[^.]+$//;
    chomp $timestamp_from_file;
    if ($timestamp_from_file > $zimbra_ldap_schema_version) {
        &print_separater("-", "80");
        open(FH, '<', $infile) or die "Cannot open file $infile for reading: $!\n";
        my $raw_json = join '', <FH>;
        my $json = new JSON::PP;
        eval {
            my $json_decoded = $json->decode($raw_json);
            print STDOUT "Executing cleanup from ", $timestamp_from_file, ".json\n";
            if (exists $json_decoded->{"delete"}) {
                my @attributes = @{$json_decoded->{"delete"}};
                $failed = &apply_cleanup(\@attributes);
                if ($failed) {
                    print STDERR "Cleanup from ", $timestamp_from_file, ".json failed.\n";
                }
            }
            if (!$failed && exists $json_decoded->{"ldif"}) {
                my @ldifs = @{$json_decoded->{"ldif"}};
                $failed = &apply_ldif_cleanup(\@ldifs);
                if ($failed) {
                    print STDERR "Cleanup from ", $timestamp_from_file, ".json failed.\n";
                }
            }
            if (!$failed && exists $json_decoded->{"perl"}) {
                my @perls = @{$json_decoded->{"perl"}};
                $failed = &apply_perl_cleanup(\@perls);
                if ($failed) {
                    print STDERR "Cleanup from ", $timestamp_from_file, ".json failed.\n";
                }
            }
            # update schema version if no failure
            if (!$failed) {
                $failed = &update_zimbra_ldap_schema_version($timestamp_from_file);
                if ($failed) {
                    print STDERR "Could not update schema version to ", $timestamp_from_file, ".\n";
                }
            }
            1;
        } or do {
            my $e = $@;
            # TODO: should fail and not skip
            $failed = 1;
            print STDERR "Failed to evaluate file $timestamp_from_file.json\n    Reason: $e\n. Exiting\n";
        };
    }
    close(FH);
    return $failed;
}


=begin apply_cleanup
    apply_cleanup(@attributes<array>);
Removes provided attributes from all entries in LDAP.
returns failed status (true or false)
=cut
sub apply_cleanup {
    my ($attributes) = @_;
    foreach my $attribute (@$attributes) {
        $mesg = $ldap ->search(
            base=>"",
            filter=>"&(objectClass=*)($attribute=*)",
            scope=>"sub",
        );
        my @entries = $mesg->entries;
        my $size = @entries;
        print STDOUT "Found $size entries with attribute $attribute\n";

        foreach my $entry (@entries)  {
            my $msg = $entry->delete($attribute);
            $msg = $entry->update ( $ldap ); # applies delete
            if ( $msg->code() ) {
                print STDERR "Error msg: ", $entry->dn(), " ", $msg->error(), "\n";
                return 1;
            }
        }
    }
    return 0;
}

=begin apply_ldif_cleanup
    apply_ldif_cleanup(@attributes<array>);
Removes provided attributes from all entries in LDAP.
returns failed status (true or false)
=cut
sub apply_ldif_cleanup {
    my ($ldifFiles) = @_;
    foreach my $ldifFile (@$ldifFiles) {
        &print_separater("-", "80");
        print STDOUT "Running LDIF file $ldifFile...";
        my $ldif = Net::LDAP::LDIF->new("$ldap_attribute_cleanup_dir/$ldifFile", "r", onerror => 'warn');
        # Process the LDIF input file
        while(my $entry = $ldif->read())
        {
            my $msg = $entry->update ( $ldap ); # applies
            if ( $msg->code() ) {
                print STDERR "Error msg: ", $entry->dn(), " ", $msg->error(), "\n";
                &print_separater("-", "80");
                return 1;
            }
            print STDOUT "success.\n";
            &print_separater("-", "80");
        }
    }
    return 0;
}

=begin apply_perl_cleanup
    apply_perl_cleanup(@attributes<array>);
Runs scripts for this migrations
returns failed status (true or false)
=cut
sub apply_perl_cleanup {
    my ($perlFiles) = @_;
    foreach my $perlFile (@$perlFiles) {
        &print_separater("-", "80");
        print STDOUT "Running perl script $perlFile...\n";
        print `perl $ldap_attribute_cleanup_dir/$perlFile`;
        my $failed=@?;
        if ($failed) {
            print STDERR "failed.\n";
            &print_separater("-", "80");
            return 1;
        }
        print STDOUT "success.\n";
        &print_separater("-", "80");
    }
    return 0;
}
